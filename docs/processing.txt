ChucK's approach to audio processing is to first execute the program in a shred until the first time advance instruction (if any). Upon such an instruction, the shred's wake time is assigned the time (in samples) to advance to and the shred (and the VM) stops executing temporarily. Instead, the audio processing is started and the audio thread invokes a callback periodically which in turn resumes VM execution.

When VM execution is resumed on the audio thread, it performs its computation routine for each sample of the provided output buffer. The computation routine, when executed, looks for a shred which wake time is less than the current sample position (i.e., the number of processed samples). When a shred is ready to be woken, it is run, which means that it'll resume program execution where it left off. The shred then continues until it reaches either a time advance instruction or the program ends.


ChucKJS mirrors ChucK in that it performs an initial VM computation until either the program ends or a time advance instruction is encountered. When a time advance instruction is encountered, the VM ends suspends its computation until a certain time (in samples) and a ScriptProcessorNode is created. The latter then gets called periodically by the Web Audio API with a certain buffer size, and, like the original ChucK, it checks for every sample if the VM should be awoken (i.e., the wake time is less than the current number of processed samples). If the VM should indeed be awoken, it's made to compute until it either finishes or suspends temporarily.